<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>harvester_e2e_tests.fixtures.api_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>harvester_e2e_tests.fixtures.api_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
from datetime import datetime, timedelta
from io import StringIO
from tempfile import NamedTemporaryFile
from pathlib import Path
from subprocess import run, PIPE
from typing import Callable
from time import sleep
from inspect import getfullargspec

import pytest
from paramiko import SSHClient, RSAKey, MissingHostKeyPolicy
from pkg_resources import parse_version
from cryptography.hazmat import backends
from cryptography.hazmat.primitives import asymmetric, serialization

from harvester_api import HarvesterAPI


@pytest.fixture(scope=&#34;session&#34;)
def api_client(request):
    endpoint = request.config.getoption(&#34;--endpoint&#34;)
    username = request.config.getoption(&#34;--username&#34;)
    password = request.config.getoption(&#34;--password&#34;)
    ssl_verify = request.config.getoption(&#34;--ssl_verify&#34;, False)

    api = HarvesterAPI(endpoint)
    api.authenticate(username, password, verify=ssl_verify)

    api.session.verify = ssl_verify

    return api


@pytest.fixture(scope=&#34;session&#34;)
def wait_timeout(request):
    return request.config.getoption(&#34;--wait-timeout&#34;, 300)


@pytest.fixture(scope=&#34;session&#34;)
def sleep_timeout(request):
    return request.config.getoption(&#34;--sleep-timeout&#34;, 4)


@pytest.fixture(scope=&#34;session&#34;)
def rancher_wait_timeout(request):
    return request.config.getoption(&#34;--rancher-cluster-wait-timeout&#34;, 1800)


@pytest.fixture(scope=&#34;session&#34;)
def host_state(request):
    class HostState:
        files = (&#34;power_off.sh&#34;, &#34;power_on.sh&#34;, &#34;reboot.sh&#34;)  # [False, True, -1]

        def __init__(self, script_path, delay=120):
            self.path = Path(script_path)
            self.delay = delay

        def __repr__(self):
            return f&#34;HostState({self.path}, {self.delay})&#34;

        def power(self, name, ip, on=True):
            proc = run([self.path / self.files[on], name, ip],
                       stdout=PIPE, stderr=PIPE)
            return proc.returncode, proc.stdout, proc.stderr

        def reboot(self, name, ip):
            return self.power(name, ip, -1)

    return HostState(request.config.getoption(&#34;--node-scripts-location&#34;))


@pytest.fixture(scope=&#39;module&#39;)
def unique_name():
    &#34;&#34;&#34;Default unique name&#34;&#34;&#34;
    return datetime.now().strftime(&#34;%Hh%Mm%Ss%f-%m-%d&#34;)


@pytest.fixture(scope=&#39;module&#39;)
def gen_unique_name():
    &#34;&#34;&#34;Generate unique name on-demand&#34;&#34;&#34;
    return lambda: datetime.now().strftime(&#34;%Hh%Mm%Ss%f-%m-%d&#34;)


@pytest.fixture(scope=&#34;module&#34;)
def ssh_keypair():
    private_key = asymmetric.rsa.generate_private_key(
        public_exponent=65537,
        key_size=1024,
        backend=backends.default_backend()
    )
    private_key_pem = private_key.private_bytes(
        serialization.Encoding.PEM,
        serialization.PrivateFormat.OpenSSH,
        serialization.NoEncryption()
    )

    public_key = private_key.public_key()
    public_key_ssh = public_key.public_bytes(
        serialization.Encoding.OpenSSH,
        serialization.PublicFormat.OpenSSH
    )

    return public_key_ssh.decode(&#39;utf-8&#39;), private_key_pem.decode(&#39;utf-8&#39;)


@pytest.fixture(scope=&#34;session&#34;)
def fake_image_file():
    with NamedTemporaryFile(&#34;wb&#34;) as f:
        f.seek(10 * 1024 ** 2 - 1)  # 10MB
        f.write(b&#34;\0&#34;)
        f.seek(0)
        yield Path(f.name)


@pytest.fixture(scope=&#34;session&#34;)
def support_bundle_state():
    class SupportBundle:
        def __init__(self, fio):
            self.uid = &#34;&#34;
            self.files = list()  # for checking file name
            self.fio = fio  # for checking file content

    with NamedTemporaryFile() as f:
        yield SupportBundle(f)


@pytest.fixture(scope=&#34;session&#34;)
def expected_settings():
    return {
        &#34;1.1.0&#34;: {&#39;storage-network&#39;, &#39;containerd-registry&#39;, &#39;ui-plugin-index&#39;},
        &#34;default&#34;: {
            &#39;additional-ca&#39;,
            &#39;auto-disk-provision-paths&#39;,
            &#39;backup-target&#39;,
            &#39;cluster-registration-url&#39;,
            &#39;http-proxy&#39;,
            &#39;log-level&#39;,
            &#39;overcommit-config&#39;,
            &#39;release-download-url&#39;,
            &#39;server-version&#39;,
            &#39;ssl-certificates&#39;,
            &#39;ssl-parameters&#39;,
            &#39;support-bundle-image&#39;,
            &#39;support-bundle-namespaces&#39;,
            &#39;support-bundle-timeout&#39;,
            &#39;ui-index&#39;,
            &#39;ui-source&#39;,
            &#39;upgrade-checker-enabled&#39;,
            &#39;upgrade-checker-url&#39;,
            &#39;vip-pools&#39;,
            &#39;vm-force-reset-policy&#39;,
        }
    }


@pytest.fixture(autouse=True)
def skip_version_before(request, api_client):
    mark = request.node.get_closest_marker(&#34;skip_version_before&#34;)
    if mark:
        cluster_ver = api_client.cluster_version
        for target_ver in mark.args:
            if &#39;-head&#39; not in cluster_ver.public and parse_version(target_ver) &gt; cluster_ver:
                return pytest.skip(
                    f&#34;Cluster Version `{api_client.cluster_version}` is not included&#34;
                    f&#34; in the supported version (most &gt;= `{target_ver}`)&#34;
                )


@pytest.fixture(autouse=True)
def skip_version_after(request, api_client):
    mark = request.node.get_closest_marker(&#34;skip_version_after&#34;)
    if mark:
        cluster_ver = api_client.cluster_version
        for target_ver in mark.args:
            if not hasattr(cluster_ver, &#39;major&#39;) or parse_version(target_ver) &lt;= cluster_ver:
                return pytest.skip(
                    f&#34;Cluster Version `{api_client.cluster_version}` is not included&#34;
                    f&#34; in the supported version (most &lt; `{target_ver}`)&#34;
                )


@pytest.fixture(scope=&#34;session&#34;)
def host_shell(request):
    password = request.config.getoption(&#34;--host-password&#34;) or None
    pkey = request.config.getoption(&#39;--host-private-key&#39;) or None
    if pkey:
        pkey = RSAKey.from_private_key(StringIO(pkey))

    class HostShell:
        _client = _jump = None

        def __init__(self, username, password=None, pkey=None):
            self.username = username
            self.password = password
            self.pkey = pkey

        def __enter__(self):
            return self

        def __exit__(self, exc_type, exc_value, exc_tb):
            self.logout()

        @property
        def client(self):
            return self._client

        def reconnect(self, ipaddr, port=22, **kwargs):
            if self.client:
                self.client.close()
                self._client = cli = SSHClient()
                cli.set_missing_host_key_policy(MissingHostKeyPolicy())
                kws = dict(username=self.username, password=self.password, pkey=self.pkey)
                kws.update(kwargs)
                cli.connect(ipaddr, port, **kws)

        def login(self, ipaddr, port=22, jumphost=False, **kwargs):
            if not self.client:
                cli = SSHClient()
                cli.set_missing_host_key_policy(MissingHostKeyPolicy())
                kws = dict(username=self.username, password=self.password, pkey=self.pkey)
                kws.update(kwargs)
                cli.connect(ipaddr, port, **kws)
                self._client = cli

                if jumphost:
                    self.jumphost_policy()
                    self._jump = True
                    self.reconnect(ipaddr, port, **kws)

            return self

        def logout(self):
            if self.client and self.client.get_transport():
                if self._jump:
                    self.jumphost_policy(False)
                    self._jump = None
                self.client.close()
                self._client = None

        def exec_command(self, command, bufsize=-1, timeout=None, get_pty=False, env=None,
                         splitlines=False):
            _, out, err = self.client.exec_command(command, bufsize, timeout, get_pty, env)
            out, err = out.read().decode(), err.read().decode()
            if splitlines:
                out = out.splitlines()
            return out, err

        def jumphost_policy(self, allow=True):
            ctx, err = self.exec_command(&#34;sudo cat /etc/ssh/sshd_config&#34;)
            if allow:
                renew = re.sub(r&#39;\n(Allow(?:Tcp|Agent)Forwarding no)&#39;,
                               lambda m: f&#34;\n#{m.group(1)}&#34;, ctx, re.I | re.M)
            else:
                renew = re.sub(r&#39;#(Allow(?:Tcp|Agent)Forwarding no)&#39;,
                               lambda m: m.group(1), ctx, re.I | re.M)
            self.exec_command(f&#39;sudo cat&lt;&lt;&#34;EOF&#34;&gt;_config\n{renew}EOF&#39;)
            self.exec_command(&#39;sudo mv _config /etc/ssh/sshd_config&#39;
                              &#39; &amp;&amp; sudo systemctl restart sshd&#39;)

    return HostShell(&#39;rancher&#39;, password, pkey)


@pytest.fixture(scope=&#34;session&#34;)
def polling_for(wait_timeout, sleep_timeout):
    # TODO: Try to redesign refer to multiprocessing package (e.g. apply_async and map_async)
    def _polling_for(subject: str,
                     checker: Callable[..., bool],
                     poller: Callable, *args,
                     timeout=wait_timeout):
        &#34;&#34;&#34; Polling expected confition for `timeout`s every `sleep_timeout`s

        Arguments:
          subject: str, what is waiting for
          checker: Callable, check `poller` output and returns bool
          args: list, [*poller_args, testee]
          poller: Callable, poller(*poller_args, testee) for each testee

        Returns:
          Any: `poller` output if qualified by `checker`

        Raises:
          AssertionError: if still NOT qualified within `timeout`s
        &#34;&#34;&#34;
        *poller_args, testee = args
        testees = testee if isinstance(testee, list) else [testee]
        checker_args_len = len(getfullargspec(checker).args)

        endtime = datetime.now() + timedelta(seconds=timeout)
        while endtime &gt; datetime.now():
            for testee in testees[:]:
                output = poller(*poller_args, testee)
                # unpack poller output according to checker signature
                qualified = checker(*output) if checker_args_len &gt; 1 else checker(output)
                if qualified:
                    testees.remove(testee)
            if not testees:
                return output
            sleep(sleep_timeout)
        else:
            raise AssertionError(
                f&#39;Timeout {timeout}s waiting for {subject}\n&#39;
                f&#39;Got error: {output}&#39;
            )

    return _polling_for</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="harvester_e2e_tests.fixtures.api_client.api_client"><code class="name flex">
<span>def <span class="ident">api_client</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def api_client(request):
    endpoint = request.config.getoption(&#34;--endpoint&#34;)
    username = request.config.getoption(&#34;--username&#34;)
    password = request.config.getoption(&#34;--password&#34;)
    ssl_verify = request.config.getoption(&#34;--ssl_verify&#34;, False)

    api = HarvesterAPI(endpoint)
    api.authenticate(username, password, verify=ssl_verify)

    api.session.verify = ssl_verify

    return api</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.expected_settings"><code class="name flex">
<span>def <span class="ident">expected_settings</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def expected_settings():
    return {
        &#34;1.1.0&#34;: {&#39;storage-network&#39;, &#39;containerd-registry&#39;, &#39;ui-plugin-index&#39;},
        &#34;default&#34;: {
            &#39;additional-ca&#39;,
            &#39;auto-disk-provision-paths&#39;,
            &#39;backup-target&#39;,
            &#39;cluster-registration-url&#39;,
            &#39;http-proxy&#39;,
            &#39;log-level&#39;,
            &#39;overcommit-config&#39;,
            &#39;release-download-url&#39;,
            &#39;server-version&#39;,
            &#39;ssl-certificates&#39;,
            &#39;ssl-parameters&#39;,
            &#39;support-bundle-image&#39;,
            &#39;support-bundle-namespaces&#39;,
            &#39;support-bundle-timeout&#39;,
            &#39;ui-index&#39;,
            &#39;ui-source&#39;,
            &#39;upgrade-checker-enabled&#39;,
            &#39;upgrade-checker-url&#39;,
            &#39;vip-pools&#39;,
            &#39;vm-force-reset-policy&#39;,
        }
    }</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.fake_image_file"><code class="name flex">
<span>def <span class="ident">fake_image_file</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def fake_image_file():
    with NamedTemporaryFile(&#34;wb&#34;) as f:
        f.seek(10 * 1024 ** 2 - 1)  # 10MB
        f.write(b&#34;\0&#34;)
        f.seek(0)
        yield Path(f.name)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.gen_unique_name"><code class="name flex">
<span>def <span class="ident">gen_unique_name</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate unique name on-demand</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#39;module&#39;)
def gen_unique_name():
    &#34;&#34;&#34;Generate unique name on-demand&#34;&#34;&#34;
    return lambda: datetime.now().strftime(&#34;%Hh%Mm%Ss%f-%m-%d&#34;)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.host_shell"><code class="name flex">
<span>def <span class="ident">host_shell</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def host_shell(request):
    password = request.config.getoption(&#34;--host-password&#34;) or None
    pkey = request.config.getoption(&#39;--host-private-key&#39;) or None
    if pkey:
        pkey = RSAKey.from_private_key(StringIO(pkey))

    class HostShell:
        _client = _jump = None

        def __init__(self, username, password=None, pkey=None):
            self.username = username
            self.password = password
            self.pkey = pkey

        def __enter__(self):
            return self

        def __exit__(self, exc_type, exc_value, exc_tb):
            self.logout()

        @property
        def client(self):
            return self._client

        def reconnect(self, ipaddr, port=22, **kwargs):
            if self.client:
                self.client.close()
                self._client = cli = SSHClient()
                cli.set_missing_host_key_policy(MissingHostKeyPolicy())
                kws = dict(username=self.username, password=self.password, pkey=self.pkey)
                kws.update(kwargs)
                cli.connect(ipaddr, port, **kws)

        def login(self, ipaddr, port=22, jumphost=False, **kwargs):
            if not self.client:
                cli = SSHClient()
                cli.set_missing_host_key_policy(MissingHostKeyPolicy())
                kws = dict(username=self.username, password=self.password, pkey=self.pkey)
                kws.update(kwargs)
                cli.connect(ipaddr, port, **kws)
                self._client = cli

                if jumphost:
                    self.jumphost_policy()
                    self._jump = True
                    self.reconnect(ipaddr, port, **kws)

            return self

        def logout(self):
            if self.client and self.client.get_transport():
                if self._jump:
                    self.jumphost_policy(False)
                    self._jump = None
                self.client.close()
                self._client = None

        def exec_command(self, command, bufsize=-1, timeout=None, get_pty=False, env=None,
                         splitlines=False):
            _, out, err = self.client.exec_command(command, bufsize, timeout, get_pty, env)
            out, err = out.read().decode(), err.read().decode()
            if splitlines:
                out = out.splitlines()
            return out, err

        def jumphost_policy(self, allow=True):
            ctx, err = self.exec_command(&#34;sudo cat /etc/ssh/sshd_config&#34;)
            if allow:
                renew = re.sub(r&#39;\n(Allow(?:Tcp|Agent)Forwarding no)&#39;,
                               lambda m: f&#34;\n#{m.group(1)}&#34;, ctx, re.I | re.M)
            else:
                renew = re.sub(r&#39;#(Allow(?:Tcp|Agent)Forwarding no)&#39;,
                               lambda m: m.group(1), ctx, re.I | re.M)
            self.exec_command(f&#39;sudo cat&lt;&lt;&#34;EOF&#34;&gt;_config\n{renew}EOF&#39;)
            self.exec_command(&#39;sudo mv _config /etc/ssh/sshd_config&#39;
                              &#39; &amp;&amp; sudo systemctl restart sshd&#39;)

    return HostShell(&#39;rancher&#39;, password, pkey)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.host_state"><code class="name flex">
<span>def <span class="ident">host_state</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def host_state(request):
    class HostState:
        files = (&#34;power_off.sh&#34;, &#34;power_on.sh&#34;, &#34;reboot.sh&#34;)  # [False, True, -1]

        def __init__(self, script_path, delay=120):
            self.path = Path(script_path)
            self.delay = delay

        def __repr__(self):
            return f&#34;HostState({self.path}, {self.delay})&#34;

        def power(self, name, ip, on=True):
            proc = run([self.path / self.files[on], name, ip],
                       stdout=PIPE, stderr=PIPE)
            return proc.returncode, proc.stdout, proc.stderr

        def reboot(self, name, ip):
            return self.power(name, ip, -1)

    return HostState(request.config.getoption(&#34;--node-scripts-location&#34;))</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.polling_for"><code class="name flex">
<span>def <span class="ident">polling_for</span></span>(<span>wait_timeout, sleep_timeout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def polling_for(wait_timeout, sleep_timeout):
    # TODO: Try to redesign refer to multiprocessing package (e.g. apply_async and map_async)
    def _polling_for(subject: str,
                     checker: Callable[..., bool],
                     poller: Callable, *args,
                     timeout=wait_timeout):
        &#34;&#34;&#34; Polling expected confition for `timeout`s every `sleep_timeout`s

        Arguments:
          subject: str, what is waiting for
          checker: Callable, check `poller` output and returns bool
          args: list, [*poller_args, testee]
          poller: Callable, poller(*poller_args, testee) for each testee

        Returns:
          Any: `poller` output if qualified by `checker`

        Raises:
          AssertionError: if still NOT qualified within `timeout`s
        &#34;&#34;&#34;
        *poller_args, testee = args
        testees = testee if isinstance(testee, list) else [testee]
        checker_args_len = len(getfullargspec(checker).args)

        endtime = datetime.now() + timedelta(seconds=timeout)
        while endtime &gt; datetime.now():
            for testee in testees[:]:
                output = poller(*poller_args, testee)
                # unpack poller output according to checker signature
                qualified = checker(*output) if checker_args_len &gt; 1 else checker(output)
                if qualified:
                    testees.remove(testee)
            if not testees:
                return output
            sleep(sleep_timeout)
        else:
            raise AssertionError(
                f&#39;Timeout {timeout}s waiting for {subject}\n&#39;
                f&#39;Got error: {output}&#39;
            )

    return _polling_for</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.rancher_wait_timeout"><code class="name flex">
<span>def <span class="ident">rancher_wait_timeout</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def rancher_wait_timeout(request):
    return request.config.getoption(&#34;--rancher-cluster-wait-timeout&#34;, 1800)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.skip_version_after"><code class="name flex">
<span>def <span class="ident">skip_version_after</span></span>(<span>request, api_client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(autouse=True)
def skip_version_after(request, api_client):
    mark = request.node.get_closest_marker(&#34;skip_version_after&#34;)
    if mark:
        cluster_ver = api_client.cluster_version
        for target_ver in mark.args:
            if not hasattr(cluster_ver, &#39;major&#39;) or parse_version(target_ver) &lt;= cluster_ver:
                return pytest.skip(
                    f&#34;Cluster Version `{api_client.cluster_version}` is not included&#34;
                    f&#34; in the supported version (most &lt; `{target_ver}`)&#34;
                )</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.skip_version_before"><code class="name flex">
<span>def <span class="ident">skip_version_before</span></span>(<span>request, api_client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(autouse=True)
def skip_version_before(request, api_client):
    mark = request.node.get_closest_marker(&#34;skip_version_before&#34;)
    if mark:
        cluster_ver = api_client.cluster_version
        for target_ver in mark.args:
            if &#39;-head&#39; not in cluster_ver.public and parse_version(target_ver) &gt; cluster_ver:
                return pytest.skip(
                    f&#34;Cluster Version `{api_client.cluster_version}` is not included&#34;
                    f&#34; in the supported version (most &gt;= `{target_ver}`)&#34;
                )</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.sleep_timeout"><code class="name flex">
<span>def <span class="ident">sleep_timeout</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def sleep_timeout(request):
    return request.config.getoption(&#34;--sleep-timeout&#34;, 4)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.ssh_keypair"><code class="name flex">
<span>def <span class="ident">ssh_keypair</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;module&#34;)
def ssh_keypair():
    private_key = asymmetric.rsa.generate_private_key(
        public_exponent=65537,
        key_size=1024,
        backend=backends.default_backend()
    )
    private_key_pem = private_key.private_bytes(
        serialization.Encoding.PEM,
        serialization.PrivateFormat.OpenSSH,
        serialization.NoEncryption()
    )

    public_key = private_key.public_key()
    public_key_ssh = public_key.public_bytes(
        serialization.Encoding.OpenSSH,
        serialization.PublicFormat.OpenSSH
    )

    return public_key_ssh.decode(&#39;utf-8&#39;), private_key_pem.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.support_bundle_state"><code class="name flex">
<span>def <span class="ident">support_bundle_state</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def support_bundle_state():
    class SupportBundle:
        def __init__(self, fio):
            self.uid = &#34;&#34;
            self.files = list()  # for checking file name
            self.fio = fio  # for checking file content

    with NamedTemporaryFile() as f:
        yield SupportBundle(f)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.unique_name"><code class="name flex">
<span>def <span class="ident">unique_name</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Default unique name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#39;module&#39;)
def unique_name():
    &#34;&#34;&#34;Default unique name&#34;&#34;&#34;
    return datetime.now().strftime(&#34;%Hh%Mm%Ss%f-%m-%d&#34;)</code></pre>
</details>
</dd>
<dt id="harvester_e2e_tests.fixtures.api_client.wait_timeout"><code class="name flex">
<span>def <span class="ident">wait_timeout</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture(scope=&#34;session&#34;)
def wait_timeout(request):
    return request.config.getoption(&#34;--wait-timeout&#34;, 300)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="harvester_e2e_tests.fixtures" href="index.html">harvester_e2e_tests.fixtures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="harvester_e2e_tests.fixtures.api_client.api_client" href="#harvester_e2e_tests.fixtures.api_client.api_client">api_client</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.expected_settings" href="#harvester_e2e_tests.fixtures.api_client.expected_settings">expected_settings</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.fake_image_file" href="#harvester_e2e_tests.fixtures.api_client.fake_image_file">fake_image_file</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.gen_unique_name" href="#harvester_e2e_tests.fixtures.api_client.gen_unique_name">gen_unique_name</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.host_shell" href="#harvester_e2e_tests.fixtures.api_client.host_shell">host_shell</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.host_state" href="#harvester_e2e_tests.fixtures.api_client.host_state">host_state</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.polling_for" href="#harvester_e2e_tests.fixtures.api_client.polling_for">polling_for</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.rancher_wait_timeout" href="#harvester_e2e_tests.fixtures.api_client.rancher_wait_timeout">rancher_wait_timeout</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.skip_version_after" href="#harvester_e2e_tests.fixtures.api_client.skip_version_after">skip_version_after</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.skip_version_before" href="#harvester_e2e_tests.fixtures.api_client.skip_version_before">skip_version_before</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.sleep_timeout" href="#harvester_e2e_tests.fixtures.api_client.sleep_timeout">sleep_timeout</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.ssh_keypair" href="#harvester_e2e_tests.fixtures.api_client.ssh_keypair">ssh_keypair</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.support_bundle_state" href="#harvester_e2e_tests.fixtures.api_client.support_bundle_state">support_bundle_state</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.unique_name" href="#harvester_e2e_tests.fixtures.api_client.unique_name">unique_name</a></code></li>
<li><code><a title="harvester_e2e_tests.fixtures.api_client.wait_timeout" href="#harvester_e2e_tests.fixtures.api_client.wait_timeout">wait_timeout</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>